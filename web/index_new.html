<html>
<head>
	<title>Dijkstra PouchDB Tests</title>
</head>
<body>
	asdf
</body>
<!-- <script src="js/levelgraph.min.js"></script> -->
<script src="js/pouchdb-5.2.0.min.js"></script>
<script src="js/geopouch-downloaded.js"></script>
<script src="js/underscore-min.js"></script>
<script>
	// var graphdb = levelgraph(level("vienna_roads_graph"));
    PouchDB.plugin(geopouch);
	var docdb = new PouchDB('http://gi88.geoinfo.tuwien.ac.at:5984/vienna_graph2');
    var localdocdb = new PouchDB('vienna_road_docs');
	var batchpos = 0;
    
    // global Variables for collecting the results of the Dijkstra calculation
    /* dmap is the buffer for the Dijkstra. It is a collection of objects, each having
       an array as key which represents the 'from' and 'to' node (e.g. [A,B] ). The value
       is also an array of three values, specifying the target node, the cost to get there
       and whether this node was visited or not (e.g. [A,90,0] ).
    */
    var dmap = {};
    var accumulatedCosts = 0;
    var path = [];
    var endNode;
    
    // the following code-block syncs the local pouchDB with the remote couchDB and activates live-sync
    
    
    PouchDB.replicate(docdb, localdocdb, {live: true,
                                          retry: true }).on('complete', function()    { console.log("sync complete") })
                                                        .on('error',    function(err) { console.log(err)  })
                                                        .on('active',   function()    { console.log("sync watchdog barking") })
                                                        .on('change',   function()    { console.log("change in db detected, syncing ...") });
    
    //getEdgesFromNode(4);
    
    function getEdgesFromNode(nodeID){
        console.log("query for outgoing edges of node #"+nodeID+" ...");
        localdocdb.query('graph/edgesofnode', {key: nodeID, reduce: false, include_docs: true})
                                            .then( function (res) {
                                                console.log("result of query for node #"+nodeID+":");
                                                console.log(res);
                                            }).catch(function(err) {
                                                console.log("ERROR of query for node #"+nodeID+":");
                                                console.log(err);
                                            });
    };
    
    function getDijkstra(startNode,userEndNode) {
        console.log("Dijkstra start ...");
        /* DIJKSTRA SAYS
           Weise allen Knoten die beiden Eigenschaften „Distanz“ und „Vorgänger“ zu. Initialisiere die Distanz im Startknoten mit 0 und in allen anderen Knoten mit ∞. Setze den Vorgänger des Startknotens auf sich selber
        */
        dmap[startNode] = {'cost': 0, 'origin': startNode, 'visited': true};
        accumulatedCosts = 0;
        // path.push(startNode);
        dijkstraRecursion(startNode);
    }
    
    function dijkstraRecursion(currentNode){
        // we start with querying all outgoing edges from the given node
        localdocdb.query('graph/edgesofnode', {key: currentNode, reduce: false, include_docs: true})
            .then(function (results){
                // format of each result-entry: (id): edge-id, (key): from-id, (value): [to-id,cost]
                /* DIJKSTRA SAYS
                   Solange es noch unbesuchte Knoten gibt, wähle darunter denjenigen mit minimaler Distanz aus
                */
                //console.log("Dijkstra: all targets from node " + currentNode);
                //console.log(results.rows);
                
                // for easier readability we reformat the given structure
                var nodesList = _.map(results.rows, function(node){return {'nodeid': node.value[0], 'cost': node.value[1], 'origin': node.key}; });
                console.log(nodesList);
                
                // keep only the not yet visited nodes
                console.log("Dijkstra: isNodeUnvisited");
                unvisitedNodesList = _.filter(nodesList,isNodeUnvisited);
                console.log("Dijkstra: unvisitedNodesList:");
                console.log(unvisitedNodesList);
                
                // get the cheapest targetNode
                var cheapestNode = _.min(unvisitedNodesList, function(entry){return entry.cost;} );
                console.log("Dijkstra: cheapest node:");
                console.log(cheapestNode);
                
                cheapestNode.visited = true;
                dmap[cheapestNode.nodeid] = cheapestNode;
                path.push(cheapestNode);
                console.log(dmap)
                
                //dijkstraRecursion(cheapestNode.nodeid);
            })
            .catch(function (err){
                console.log("Dijkstra: ERROR of query for node #"+currentNode);
                console.log(err);
            });
    }
    
    /* This function is the filter function to find out whether an given resulting (edge->)node
       has already been marked as visited in the dmap variable.
       A node is not yet visited if it is not contained in the dmap or it is contained, but not
       marked as visited. */
    function isNodeUnvisited(node){
        // console.log(node);
        if      ( ! dmap[node.nodeid] )         {return true;}      // value not existing in dmap
        else if (   dmap[node.nodeid][2] == 0 ) {return true;}      // it exists, but was not yet visited
        else if (   dmap[node.nodeid][2] == 1 ) {return false;};    // value visited and existing
    }

</script>
</html>
